# Herança em Java

## Conceito de Herança

Herança é um conceito no qual uma classe, chamada **subclasse (filha)**, herda propriedades e métodos de outra classe, chamada **superclasse (mãe)**.

Ela promove:

- Reutilização de código
    
- Organização em hierarquias
    
- Facilidade de manutenção
    

Além disso, permite que a subclasse **altere o comportamento** de métodos da classe mãe, tornando o sistema mais flexível.

---

## Superclasse e Subclasse

A **superclasse** é a classe que fornece atributos e métodos.  
A **subclasse** é a classe que herda esses recursos.

A palavra-chave `extends` é usada para definir herança.

### Exemplo básico

`// Superclasse class Animal {     String name;      void sound() {         System.out.println("Som genérico");     } }  // Subclasse class Dog extends Animal { }`

---

## Funcionamento da Herança

Uma subclasse herda:

- Membros `public`
    
- Membros `protected`
    

Ela **não herda membros `private`**.

### Exemplo

`class Animal {     protected String name; }  class Dog extends Animal {     void showName() {         System.out.println(name);     } }`

---

## Tipos de Herança

### Herança Única

Uma classe herda de **apenas uma superclasse**.

`class Dog extends Animal { }`

---

### Herança Multinível

Uma subclasse herda de outra subclasse.

`class Puppy extends Dog { }`

Nesse caso:

- `Puppy` herda de `Dog`
    
- `Dog` herda de `Animal`
    

---

### Herança Hierárquica

Várias subclasses herdam da **mesma superclasse**.

`class Cat extends Animal {     void meow() {         System.out.println("Cat meows");     } }  class Dog extends Animal {     void bark() {         System.out.println("Dog barks");     } }`

---

### Herança Múltipla

A herança múltipla **não é suportada diretamente em Java**, pois pode causar ambiguidade.

Ela pode ser implementada **usando interfaces**.

`interface Fly {     void fly(); }  interface Swim {     void swim(); }  class Duck implements Fly, Swim {     public void fly() {         System.out.println("Duck flies");     }      public void swim() {         System.out.println("Duck swims");     } }`

---

## Observações sobre Herança

- Em jogos, personagens podem compartilhar atributos comuns e ter habilidades únicas
    
- Componentes de interface gráfica podem herdar comportamentos padrões e personalizar ações
    

---

# Polimorfismo

## Conceito de Polimorfismo

Polimorfismo permite que objetos compartilhem a **mesma interface**, mas exibam **comportamentos diferentes**.

### Exemplo conceitual

Biometria pode ser usada para:

- Desbloquear celular
    
- Validar senhas
    

A ação é a mesma, mas o contexto muda.

---

## Polimorfismo em Tempo de Compilação (Sobrecarga)

Ocorre quando métodos têm:

- O mesmo nome
    
- Parâmetros diferentes
    

O método correto é escolhido **em tempo de compilação**.

`class Calculator {      int sum(int a, int b) {         return a + b;     }      int sum(int a, int b, int c) {         return a + b + c;     } }`

---

## Polimorfismo em Tempo de Execução (Sobrescrita)

Ocorre quando uma subclasse **substitui** um método da superclasse.

O método executado depende do **tipo real do objeto**.

### Exemplo

`class Animal {     void sound() {         System.out.println("Barulho aleatório");     } }  class Dog extends Animal {     @Override     void sound() {         System.out.println("Dog barks");     } }  class Cat extends Animal {     @Override     void sound() {         System.out.println("Cat meows");     } }`

### Uso no programa

`public class Main {      public static void main(String[] args) {         Animal myAnimal;          myAnimal = new Dog();         myAnimal.sound();          myAnimal = new Cat();         myAnimal.sound();     } }`

---

## Métodos Virtuais

Métodos virtuais são aqueles que **podem ser sobrescritos**.

Em Java:

- Todos os métodos **não estáticos** são virtuais por padrão
    

Isso garante a resolução dinâmica do método em tempo de execução.

---

## Aplicações do Polimorfismo

- Código genérico e reutilizável
    
- Menor acoplamento
    
- Facilidade de manutenção
    
- Melhor organização em sistemas complexos
    

---

# Abstração

## Conceito de Abstração

Abstração simplifica sistemas complexos ao:

- Ocultar detalhes internos
    
- Expor apenas funcionalidades essenciais
    

### Exemplo

Ao abrir um aplicativo:

- Você usa a funcionalidade
    
- Não precisa entender a lógica interna
    

---

## Como a Abstração é Implementada

A abstração é alcançada por:

- Interfaces
    
- Classes abstratas
    

---

# Interfaces em Java

## Conceito de Interface

Uma interface define um **contrato** que as classes devem seguir.

### Características

- Contém assinaturas de métodos
    
- Não possui construtores
    
- Métodos são `public` por padrão
    
- Suporta herança múltipla
    

---

## Exemplo de Interface

`interface Payment {     void processPayment(); }  class CreditCardPayment implements Payment {     public void processPayment() {         System.out.println("Processing credit card payment");     } }`

---

# Classes Abstratas

## Conceito de Classe Abstrata

Uma classe abstrata:

- Não pode ser instanciada
    
- Pode conter métodos abstratos e concretos
    

---

## Exemplo de Classe Abstrata

`abstract class Shape {      abstract void draw();      void info() {         System.out.println("This is a shape");     } }  class Circle extends Shape {     void draw() {         System.out.println("Drawing a circle");     } }`

---

## Vantagens das Classes Abstratas

- Reutilização de código
    
- Suporte ao polimorfismo
    
- Maior flexibilidade e manutenção
    

---

# Classes Internas (Inner Classes)

## Conceito de Classe Interna

Uma classe interna é definida **dentro de outra classe**.

Ela pode acessar:

- Variáveis
    
- Métodos da classe externa
    

---

## Exemplo de Classe Interna

`class OuterClass {     int outerVariable = 10;      class InnerClass {         void display() {             System.out.println("Outer variable value: " + outerVariable);         }     } }`

---

## Usando Classe Interna

`public class Main {     public static void main(String[] args) {         OuterClass outer = new OuterClass();         OuterClass.InnerClass inner = outer.new InnerClass();         inner.display();     } }`

---

## Tipos de Classes Internas

### Classe Interna Não Estática

- Acessa membros estáticos e não estáticos
    

---

### Classe Interna Estática (Aninhada)

- Não acessa membros não estáticos diretamente
    

`class OuterClass {     static class StaticInner {         void display() {             System.out.println("Static inner class");         }     } }`

---

### Classe Interna Local ao Método

Definida dentro de um método.

`class OuterClass {     void myMethod() {         class MethodLocalInner {             void display() {                 System.out.println("Inside Method Local Inner Class");             }         }          MethodLocalInner inner = new MethodLocalInner();         inner.display();     } }`

---

### Classe Interna Anônima

Não possui nome e é usada uma única vez.

`Runnable r = new Runnable() {     public void run() {         System.out.println("Running anonymous class");     } };`

---

## Exemplo Prático de Classe Interna

`class Library {      class Book {         String name;         int year;          Book(String name, int year) {             this.name = name;             this.year = year;         }     } }`

### Instanciando

`Library myLibrary = new Library(); Library.Book myBook = myLibrary.new Book("Java Basics", 2024);`